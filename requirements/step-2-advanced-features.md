# Step 2: Advanced Features

> **Note:** World wrapping functionality has been temporarily skipped to focus on improving world generation and entity rendering. The world is now large enough that wrapping issues occur less frequently.

## Overview

This document outlines the next phase of development, building upon the solid foundation established in Step 1. Step 2 focuses on implementing core gameplay systems, collision detection, UI elements, world structure, and developer tools.

---

## ğŸ¯ Step 2 Overview

**Goal:** Transform the basic movement prototype into a functional game with world structure, obstacles, UI, and core systems.

**Prerequisites:** Step 1 must be 100% complete (âœ… Confirmed)

---

## ğŸ§± Core Systems Implementation

### 1. World Background & Visual Feedback âœ… (COMPLETED)
- **Current Status:** Background texture system fully implemented
- **Implemented Features:**
  - Background texture for entire playable world (replaces black void) âœ…
  - Simple, lightweight texture (dots pattern rendered on canvas) âœ…
  - Consistent texture across world for relative motion reference âœ…
  - Background texture is purely aesthetic (no complex proc gen needed) âœ…
  - Dots fixed in world coordinates (player moves past them) âœ…
  - Console commands for configuration (`bgconfig`, `bgset`, `bgpreset`) âœ…
- **Configuration System:**
  - Dot size, spacing, color, and alpha are fully configurable âœ…
  - Type conversion and validation for all properties âœ…
  - Preset configurations (dense, sparse, bright, subtle) âœ…
  - Dots are placed at fixed world coordinates regardless of zoom âœ…
  - Provides proper visual feedback for player movement âœ…

### 2. World Structure & Wrapping âœ… (COMPLETED)
- **Current Status:** World structure implemented, wrapping system skipped for now
- **Implemented Features:**
  - Finite rectangular world with edge wrapping âœ…
  - Moving east leads to west side, west to east, north to south, south to north âœ…
  - Initial world size: player can traverse edge-to-edge in 10-15 seconds âœ…
  - Configurable world size for future expansion âœ…
  - Handle coordinate wrapping in movement and rendering systems âœ…
  - Deterministic starting position based on world seed âœ…
  - Console commands for world management (`worldinfo`, `setseed`, `restartgame`) âœ…
- **World Configuration:**
  - 100x100 tile world (4000x4000 pixels) âœ…
  - ~20 second traversal time at default speed âœ…
  - Red boundary line shows world edges âœ…
  - Grid system for tile-based operations âœ…
  - Coordinate wrapping prevents out-of-bounds movement âœ…
  - Configurable via gridWidth/gridHeight in world.js âœ…

### 3. Grass Tiles & Basic World Objects âœ… (COMPLETED)
- **Current Status:** Procedural generation system fully implemented
- **Implemented Features:**
  - Procedural placement of grass tiles at deterministic coordinates âœ…
  - Grass tiles visually distinct from background texture (green clusters) âœ…
  - Grass tiles are non-interactive in Step 2 (no harvesting yet) âœ…
  - Basic world objects (trees, rocks) for collision testing âœ…
  - All objects deterministically placed based on world seed âœ…
- **Generation System:**
  - Grass: 15% of tiles with natural cluster rendering âœ…
  - Trees: 5% of tiles with trunk and foliage âœ…
  - Rocks: 3% of tiles with gray circular appearance âœ…
  - Deterministic hash-based placement algorithm âœ…
  - Console command `worldobjects` for generation info âœ…
  - Natural grass blade clusters with varied directions âœ…
  - Tree rendering with brown trunk and green foliage âœ…
  - Rock rendering with gray fill and dark outline âœ…

### 4. Procedural Generation & Starting Position âœ… (COMPLETED)
- **Current Status:** Procedural generation and starting position system fully implemented
- **Implemented Features:**
  - Deterministic starting position selection based on world seed âœ…
  - Starting position ensures initial grid (red 'X') is visible âœ…
  - Consistent starting position across game sessions with same seed âœ…
  - Console command `restartGame(seed)` to restart with new seed âœ…
  - Procedural generation algorithm for deterministic world layout âœ…
- **Generation System:**
  - Hash-based deterministic starting position calculation âœ…
  - Starting position avoids world edges for visibility âœ…
  - Console command `setseed <seed>` for manual seed setting âœ…
  - Console command `restartgame` for random seed restart âœ…
  - Console command `worldinfo` shows starting position âœ…
  - Chunk cache clearing when seed changes âœ…
  - Consistent world layout across sessions with same seed âœ…

### 5. Basic Persistence System âœ… (COMPLETED)
- **Current Status:** Persistence system fully implemented
- **Implemented Features:**
  - Periodic saving of player position and world seed to localStorage âœ…
  - Singleton timeout function for state snapshots âœ…
  - Game world tick number persistence âœ…
  - Resume game exactly where left off after browser refresh âœ…
  - No world state changes to persist yet (harvesting comes later) âœ…
- **Persistence System:**
  - Automatic saving every 5 seconds âœ…
  - Manual save/load commands (`save`, `load`) âœ…
  - Save information display (`saveinfo`) âœ…
  - Save management (`clearsave`, `persistence`) âœ…
  - State validation and error handling âœ…
  - Beforeunload event saving âœ…
  - Configurable save interval and auto-save toggle âœ…
  - Player position, angle, speed persistence âœ…
  - World seed persistence âœ…
  - Game settings (perspective, zoom) persistence âœ…

### 6. Obstacles and Collision Detection âœ… (COMPLETED)
- **Current Status:** Collision detection system fully implemented
- **Implemented Features:**
  - Collision detection between player and world objects (trees, rocks) âœ…
  - Solid obstacles that block player movement âœ…
  - Collision detection works in both perspective modes âœ…
  - Visual feedback for collision (debug circles) âœ…
  - Support for different collision types (solid, passable) âœ…
  - Spatial partitioning for efficient collision detection âœ…
- **Collision System:**
  - Circular collision detection with configurable radii âœ…
  - Player collision radius: 15px (configurable) âœ…
  - Tree collision radius: 18px âœ…
  - Rock collision radius: 12px âœ…
  - Spatial grid optimization for performance âœ…
  - Console commands for collision management âœ…
  - Debug visualization with collision circles âœ…
  - Toggle collision detection on/off âœ…

### 7. Responsive Full-Screen Canvas System âœ… (COMPLETED)
- **Current Status:** Responsive canvas system fully implemented
- **Implemented Features:**
  - Canvas takes up entire browser window when maximized âœ…
  - Responsive to viewport size changes (window resize, dev tools, etc.) âœ…
  - Maintains gaming aspect ratios (16:9 or 4:3) regardless of viewport âœ…
  - Canvas size adjusts but game world view remains consistent âœ…
  - Proper rendering with aspect ratio constraints âœ…
  - Black bars when viewport doesn't match target aspect ratio âœ…
  - Smooth transitions during resize events âœ…
- **Responsive System:**
  - Automatic canvas sizing based on viewport dimensions âœ…
  - Aspect ratio preservation with black bars âœ…
  - Debounced resize events for performance âœ…
  - Support for multiple aspect ratios (16:9, 4:3, 21:9) âœ…
  - Console commands for canvas management âœ…
  - Minimum and maximum size constraints âœ…
  - Centered canvas positioning âœ…

### 8. Console Commands and Developer Tools âœ… (COMPLETED)
- **Current Status:** Full console system implemented
- **Implemented Commands:**
  - `teleport(x, y)` - Move player to specific world coordinates âœ…
  - `setspeed(value)` - Change player movement speed âœ…
  - `stats` - Display current player position, angle, speed âœ…
  - `setzoom(value)` - Control zoom level programmatically âœ…
  - `perspective` - Toggle between camera modes âœ…
  - `spawnitem(itemName)` - Spawn items at player location (placeholder) âœ…
  - `clear` - Clear console output âœ…
  - `version` - Show game version âœ…
  - `help` - Show available commands âœ…
- **Missing for Step 2:**
  - `restartGame(seed)` - Restart game with new seed (needs world system)
- **Features:**
  - Extensible command registry âœ…
  - Command history system âœ…
  - Global `cmd()` function for easy access âœ…
  - Error handling and validation âœ…

### 9. Basic UI System âœ… (COMPLETED)
- **Chat & Command Input Bar:**
  - Pressing the `Enter` key opens a text input bar at the bottom of the screen, similar to MMORPGs (e.g., World of Warcraft). âœ…
  - While the input bar is open, all kegit sy presses are captured as text input and do not trigger game world actions. âœ…
  - Submitting the input (by pressing `Enter` again):
    - If the text starts with `/`, it is interpreted as a console command and executed via the command system.  âœ…
    - If the text does not start with `/`, it is considered as the character "speaking" in the game world (for now, this is a placeholder; in the future, this could display as a speech bubble above the character or trigger interactions with NPCs/entities). âœ…
  - Closing the input bar (e.g., pressing `Escape`) returns control to normal game input. âœ…
  - Command history with Up/Down arrow navigation âœ…
  - Configurable history size with localStorage persistence âœ…
- **Inventory System:**
  - Inventory toggle with `B` key âœ…
  - Grid-based inventory layout (configurable, default 5x5) âœ…
  - Click detection for inventory slots âœ…
  - Visual feedback for hover and selection âœ…
  - Inventory state management (open/closed) âœ…
  - Configurable grid size (3x3 to 10x10) âœ…
  - Console commands for inventory management âœ…
  - Positioned at bottom-right of screen (leaving space for action bars) âœ…
  - Configurable opacity for inventory background âœ…
  - Configurable opacity for item icons (placeholder for future) âœ…
  - Press `B` again to close inventory âœ…
- **Action Bar System:**
  - 10-slot action bar at bottom of screen âœ…
  - Number keys 1-0 to trigger slots âœ…
  - Mouse click support for slot activation âœ…
  - Visual feedback for hover and click âœ…
  - Configurable slot count (5-20) âœ…
  - Support for future item/spell binding âœ…
  - Responsive scaling based on viewport size âœ…
  - Console commands for action bar management âœ…

### 10. Action Bar Implementation âœ… (COMPLETED)
- **Current Status:** Dual action bar system with macro support fully implemented
- **Implemented Features:**
  - Dual 10-slot action bars at bottom-left corner âœ…
  - Primary action bar: Number keys 1-0 to trigger slots âœ…
  - Secondary action bar: Shift+Number keys 1-0 to trigger slots âœ…
  - Mouse click support for slot activation âœ…
  - Visual feedback for hover and temporary click/key press âœ…
  - Configurable slot count âœ…
  - Full macro system with command-based creation and management âœ…
  - Dynamic icon generation for macros âœ…
  - Macro binding to action bar slots âœ…
- **Action Bar System:**
  - Dual action bars positioned at bottom-left corner âœ…
  - Responsive scaling based on viewport size âœ…
  - Visual feedback for hover and temporary active states âœ…
  - Number key activation (1-0 keys) for primary bar âœ…
  - Shift+Number key activation (Shift+1-0) for secondary bar âœ…
  - Mouse click activation with proper scaling âœ…
  - Configurable opacity and styling with lower opacity empty cells âœ…
  - Console commands for action bar management âœ…
  - Inventory positioned to avoid overlapping with dual action bars âœ…
  - Temporary highlighting (only during mouse press or key hold) âœ…
- **Macro System:**
  - Command-based macro creation (`/macro create name=command`) âœ…
  - Dynamic PNG icon generation with random shapes and colors âœ…
  - localStorage persistence for macro data and icons âœ…
  - Macro placement in action bar slots (`/macro place bar-slot macroName`) âœ…
  - Macro execution when action bar slots are activated âœ…
  - Example: "perspective" macro bound to Shift+0 (secondary action bar slot 10) âœ…

### 11. Crafting UI and Recipe System
- **Requirements:**
  - Crafting menu accessible from inventory
  - Display 4 starter recipes:
    - Crafting Table
    - Torch
    - Furnace
    - Wooden Spear
  - Recipe requirements and materials display
  - Craft button with success/failure feedback
  - Extensible recipe system for future items

### 12. Macro Management UI System (NEW)

**Extensibility Note:**
- The action bar binding system must be designed to support more than just macros in the future.
- It should allow binding spells, abilities, consumable items, and custom player controls (e.g., auto-run, open inventory, open quests dialog, toggle lock-action bars, etc.).
- The data model for bindings should be flexible enough to store different types of actions (macros, spells, items, controls, etc.).
- The invocation system should be extensible: currently it only invokes commands, but in the future it must be able to invoke spells, use items (showing item icons and greying out if unavailable), and trigger custom control actions.
- The UI should be able to display the correct icon and state for each binding type (e.g., item icons, spell icons, macro icons, greying out if not usable).

**Overview:**
- Introduce a visual macro management system accessible via the `/macro` command or a UI button.
- Users can create, edit, delete, and bind macros through a pop-up grid UI similar to the inventory.

**UI/UX Requirements:**
- Macro grid UI:
  - Launched from `/macro` command or UI button.
  - Grid layout, each cell is a macro slot (empty or filled).
  - Clicking an empty cell opens a macro creation dialog.
  - Clicking a filled cell opens an edit dialog for that macro.
- Macro creation dialog:
  - Input for macro name (required, unique). When this component has the focus, inputs should be blocked for movement and keybinds.
  - Input for macro command (required). When this component has the focus, inputs should be blocked for movement and keybinds.
  - PNG icon upload (with preview, not saved until macro is saved).
  - Button to generate a random icon (uses existing random icon logic, previewed but not saved until macro is saved).
  - Save button to create macro and persist to localStorage.
- Macro edit dialog (acceissible after clicking on an existing macro in the macro gird):
  - Edit name, command, or icon (upload or randomize).
  - Delete macro button.
  - Bind to action bar:
    - Dropdown to select action bar name.
    - Dropdown to select slot (populated based on selected bar).
    - If a slot is already bound, new macro replaces the old one.
  - Save changes button.
- Macro deletion:
  - Deleting a macro does not automatically remove its action bar binding; orphaned bindings are allowed.
  - If a macro is deleted, action bar slot may show missing icon or error on use (acceptable for now).

**Implementation Steps:**
1. Add `/macro` command to open the macro management UI.
2. Implement macro grid UI (modal/pop-up, similar to inventory grid).
3. Implement macro creation dialog:
   - Name, command, PNG upload, random icon, preview, save.
4. Implement macro edit dialog:
   - Edit/delete macro, change icon, rebind to action bar slot.
5. Integrate with existing macro storage and action bar binding logic.
6. Ensure all macro data (including icon) is only saved to localStorage on save.
7. Allow preview of uploaded or generated icon before saving.
8. Update documentation and help commands to reflect new macro UI system.

**Testing Requirements:**
- [ ] Macro grid UI opens from `/macro` command or button.
- [ ] Empty cell click opens creation dialog; filled cell click opens edit dialog.
- [ ] PNG upload and random icon generation work and preview correctly.
- [ ] Macros can be created, edited, deleted, and bound to action bar slots.
- [ ] Macro data is only saved on explicit save.
- [ ] Deleting a macro does not break the game if its slot is still bound.

---

## ğŸ—‚ï¸ New Files Required

### 1. `world.js` âœ… (COMPLETED)
- **Purpose:** World structure, wrapping, and procedural generation
- **Contents:**
  - World size and wrapping logic âœ…
  - Procedural generation algorithm âœ…
  - Starting position determination âœ…
  - World coordinate system management âœ…
  - Coordinate wrapping functions âœ…
  - Tile/pixel coordinate conversion âœ…
  - World boundary rendering âœ…

### 2. `background.js` âœ… (COMPLETED)
- **Purpose:** Background texture rendering
- **Contents:**
  - Background texture generation and rendering âœ…
  - World-wide texture application âœ…
  - Performance optimization for large worlds âœ…
  - Configuration system with validation âœ…

### 3. `persistence.js` âœ… (COMPLETED)
- **Purpose:** Game state persistence and loading
- **Contents:**
  - localStorage save/load functions âœ…
  - Periodic state snapshot system âœ…
  - Game tick persistence âœ…
  - State restoration on game start âœ…

### 4. `collision.js` âœ… (COMPLETED)
- **Purpose:** Collision detection and spatial query system
- **Contents:**
  - Collision detection algorithms âœ…
  - Spatial partitioning (simple grid-based for now) âœ…
  - Collision response handling âœ…
  - Support for different object types âœ…
  - Circular collision detection with configurable radii âœ…
  - Spatial grid optimization for performance âœ…
  - Debug visualization system âœ…
  - Console command integration âœ…

### 5. `responsiveCanvas.js` âœ… (COMPLETED)
- **Purpose:** Responsive full-screen canvas system
- **Contents:**
  - Viewport-responsive canvas sizing âœ…
  - Aspect ratio preservation with black bars âœ…
  - Debounced resize event handling âœ…
  - Multiple aspect ratio support (16:9, 4:3, 21:9) âœ…
  - Canvas centering and positioning âœ…
  - Size constraints and validation âœ…
  - Console command integration âœ…

### 6. `ui.js`
- **Purpose:** User interface management
- **Contents:**
  - Inventory UI rendering and logic
  - Action bar rendering and interaction
  - Crafting UI rendering and logic
  - UI state management
  - Click detection and event handling

### 7. `items.js`
- **Purpose:** Item system and management
- **Contents:**
  - Item definitions and properties
  - Inventory management
  - Item spawning and collection
  - Item rendering (shapes for now, sprites later)

### 8. `crafting.js`
- **Purpose:** Crafting system and recipes
- **Contents:**
  - Recipe definitions
  - Crafting logic and validation
  - Material requirements checking
  - Crafting success/failure handling

### 9. `console.js` âœ… (COMPLETED)
- **Purpose:** Developer console and debugging tools
- **Contents:**
  - Command registry and parsing âœ…
  - Built-in commands (teleport, stats, restart, etc.) âœ…
  - Command history and help system âœ…
  - Extensible command system âœ…

---

## ğŸ“ Implementation Priorities

### Phase 2A: World Structure (Priority 1)
1. **World Wrapping**
   - Implement finite rectangular world with edge wrapping
   - Test movement across world boundaries
   - Ensure consistent coordinate system

2. **Procedural Generation**
   - Implement deterministic starting position selection
   - Add procedural grass tile placement
   - Test consistency across game sessions

3. **Background Texture** âœ… (COMPLETED)
   - Implement simple background texture âœ…
   - Apply texture across entire world âœ…
   - Test performance and visual consistency âœ…

### Phase 2B: Persistence & Collision (Priority 2)
4. **Basic Persistence**
   - Implement localStorage save/load for player position and seed
   - Add periodic state snapshot system
   - Test game resume functionality

5. **Collision Detection**
   - Implement collision between player and obstacles
   - Add basic world objects (trees, rocks)
   - Test collision in both perspective modes

### Phase 2C: UI & Developer Tools (Priority 3)
6. **Console Commands** âœ… (COMPLETED)
   - Implement command registry âœ…
   - Add teleport, stats, restart commands âœ…
   - Test command system functionality âœ…

7. **Basic UI System**
   - Create UI rendering framework
   - Implement inventory toggle and basic layout
   - Add click detection for UI elements

8. **Action Bar**
   - Implement 10-slot action bar
   - Add keyboard and mouse interaction
   - Visual feedback system

### Phase 2D: Advanced Features (Priority 4)
9. **Crafting System**
   - Implement recipe definitions
   - Create crafting UI
   - Add basic crafting logic

10. **Item System**
    - Implement item definitions
    - Add inventory management
    - Item spawning and collection

---

## ğŸ§ª Testing Requirements

### World Structure Testing
- [ ] Player can traverse from edge to edge in 10-15 seconds
- [ ] World wrapping works correctly in all directions
- [ ] Starting position is consistent for same seed
- [ ] Background texture provides visual feedback for movement âœ…

### Procedural Generation Testing
- [ ] Same seed produces identical world layout
- [ ] Different seeds produce different layouts
- [ ] Starting position ensures initial grid is visible
- [ ] Grass tiles are placed deterministically

### Persistence Testing
- [ ] Player position is saved and restored correctly
- [ ] World seed is preserved across browser refresh
- [ ] Game resumes exactly where left off
- [ ] Periodic saving works without performance impact

### Collision Testing âœ… (COMPLETED)
- [x] Player cannot move through solid obstacles
- [x] Collision works correctly in both perspective modes
- [x] Collision detection is efficient (no performance issues)
- [x] Visual feedback for collision (optional)

### Console Commands Testing
- [ ] `teleport(x, y)` moves player to correct coordinates âœ…
- [ ] `restartGame(seed)` restarts with new seed
- [ ] `setSpeed(value)` changes movement speed âœ…
- [ ] `printPlayerStats()` displays accurate information âœ…
- [ ] Commands work in both perspective modes âœ…

### UI Testing
- [ ] Inventory opens/closes with `B` key
- [ ] Action bar responds to number keys 1-0
- [ ] Mouse clicks work on UI elements
- [ ] Visual feedback is clear and responsive

### Crafting Testing
- [ ] Crafting menu opens from inventory
- [ ] Recipes display correctly
- [ ] Crafting logic works as expected
- [ ] Success/failure feedback is clear

---

## âœ… Step 2 Completion Criteria

### Minimum Viable Step 2
- [ ] World wrapping allows edge-to-edge traversal
- [ ] Procedural generation creates consistent world layout
- [ ] Background texture provides visual feedback âœ…
- [ ] Player position and seed persist across browser refresh
- [x] Collision detection prevents movement through obstacles
- [ ] Console commands work for teleporting, restarting, and viewing stats âœ…
- [ ] Inventory can be opened/closed with `B` key
- [ ] Action bar responds to number keys 1-0

### Full Step 2 Completion
- [ ] All world structure features implemented and tested
- [ ] Complete procedural generation with grass tiles
- [ ] Full persistence system with periodic saving
- [x] Complete collision detection system
- [ ] Complete console command system with extensibility âœ…
- [ ] Full UI system with inventory, action bar, and crafting
- [ ] Item system with spawning and collection
- [ ] All systems work correctly in both perspective modes
- [ ] Performance is acceptable (60 FPS maintained)

---

## ğŸš€ Post-Step 2 Roadmap

After Step 2 completion, the game will have:
- Functional world structure with wrapping
- Procedural generation with deterministic layout
- Basic persistence system
- Functional collision and obstacle system
- Complete UI framework
- Developer tools and debugging capabilities
- Foundation for item and crafting systems

**Next phases will include:**
- Resource harvesting tools and mechanics
- Advanced world state management
- Animation systems
- Building placement system
- Combat system implementation
- Server-client architecture preparation

---

## ğŸ“‹ Development Notes

- **Modularity:** Each new system should be self-contained and expose clear APIs
- **Performance:** Maintain 60 FPS during development
- **Testing:** Test all features in both perspective modes
- **Extensibility:** Design systems to be easily expandable
- **Debugging:** Maintain console access for all major systems
- **Persistence:** Design persistence system to support future server-client model
- **World State:** Keep world state management simple in Step 2 (no harvesting yet)